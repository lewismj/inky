#pragma once

#include <string>
#include <variant>
#include <vector>


namespace inky {

    class value;
    class environment;

    /* Represents a error generated by the interpreter. */
    struct runtime_error {
        std::string message;
    };

    /* function, note l_val may be a vector of val (recursively defined) we can define fn
     * as: f: environment . value -> value  (since val may be a vector which is used to represent
     * n-ary functions.
     */
    typedef std::function<value*(std::shared_ptr<environment>,value*)> function;

    /* A value (Lisp value in this context) is a dynamically-typed hierarchical data structure
     * that represents ast node for Lisp.
     * Recursively defined in that a value (i.e. variant) may be a vector of variants.
     */
    class value {
    public:

        enum class Type { /* WIP */
            RuntimeError,
            Integer,
            Double,
            Symbol,
            Function,
            SExpression
        };

        explicit value(const runtime_error& e) : kind(Type::RuntimeError) { var = e; }
        explicit value(const long l)   : kind(Type::Integer) { var = l; }
        explicit value(const double d) : kind(Type::Double) { var = d; }
        explicit value(const std::string& s) : kind(Type::Symbol) { var = s; }
        explicit value(const function& f): kind(Type::Function) { var = f;}


    private:
        Type kind; /* The type of the value, basic type. */


        /* WIP ... */
        
        /* We need to define a fix-point combinator, to handle the vector. */
        template<typename T> using var_t = std::variant< runtime_error,
                long,
                double,
                std::string,
                function,
                std::vector<T>>;

        template <template<class> class K> struct Fix : K<Fix<K>> { using K<Fix>::K; };
        using fixed_variant = Fix<var_t>;

        fixed_variant var; /* the lisp variant value, that may be a vector of variants. */
    };

}